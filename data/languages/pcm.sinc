define alignment=4;

define space IM type=ram_space size=4 default;
define space DM type=ram_space size=4;
define space register type=register_space size=4;

define register offset=0 size=4 [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
	r31
];

define register offset=0x1000 size=4 [
	pc sp
];

define token instr(32)
	op_maj = (27, 31)
	rd     = (22, 26)
	ird    = (22, 26)
	inv    = (21, 21)
	shl    = (20, 20)
	sh     = (15, 19)
	rxryrs = (0, 14)
	rxry   = (5, 14)
	rx     = (10, 14)
	ry     = (5, 9)
	rs     = (0, 4)
;

define token imm(32)
	imm32 = (0, 31)
;

define token imm2(32)
	imm32_2 = (0, 31)
;

attach variables [ rd rx ry rs ] [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
	_  _  _  _  _  _  _  _  _  _  _   _   _   _   _   r31
];


:nop is (op_maj=0b00000 | op_maj=0b00010) & rd=31 & inv=0 & shl=0 & sh=0 & rx=31 & ry=0 & rs=31 {}


# Data moves and loads.

# Move from register to register. Really just a specialized form of the "add" instruction.
:mv rd,  rx is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=0 & (shl=0 | shl=1) & sh=0 & rx & rs=31 { rd =  rx; }
:mv rd, -rx is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx & rs=31 { rd = -rx; }
:mv rd,  #0 is (op_maj=0b00000 | op_maj=0b00010) & rd & (inv=0 | inv=1) & (shl=0 | shl=1) & sh=0 & rx=31 & rs=31 { rd = 0; }

# Load immediate.
:loadi rd, #imm32 is (op_maj=0b00001 | op_maj=0b00011) & rd & inv=0 & shl=0 & sh=0 & rx=0 & ry=0 & rs=31; imm32 { rd = imm32; }

# Load from address.
:loada rd, [#imm32] is (op_maj=0b00001 | op_maj=0b00011) & rd & inv=0 & shl=1 & sh=0 & rx=0 & ry=0 & rs=31; imm32 { rd = *[DM]imm32:4; }


# Arithmetic operations.

# Add two registers.
:add rd, rs,  rx is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=0 & (shl=0 | shl=1) & sh=0 & rx & rs { rd = rs +  rx; }
:add rd, rs,  rx >> #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=0 & shl=0 & sh & rx & rs { rd = rs +  (rx >> sh); }
:add rd, rs,  rx << #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=0 & shl=1 & sh & rx & rs { rd = rs +  (rx << sh); }

# Add immediate.
:addi rd, rs, #imm32 is (op_maj=0b00001 | op_maj=0b00011) & rd & inv=0 & shl=0 & sh=0 & rx=0 & ry=0 & rs; imm32 { rd = rs + imm32; }

# Add from address.
:adda rd, rs, [#imm32] is (op_maj=0b00001 | op_maj=0b00011) & rd & inv=0 & shl=1 & sh=0 & rx=0 & ry=0 & rs; imm32 { rd = rs + *[DM]imm32:4; }

# Subtract two registers.
:sub rd, rs, rx is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx & rs { rd = rs - rx; }
:sub rd, rs, rx >> #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=1 & shl=0 & sh & rx & rs { rd = rs - (rx >> sh); }
:sub rd, rs, rx << #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=1 & shl=1 & sh & rx & rs { rd = rs - (rx << sh); }

# Subtract immediate.
:subi rd, rs, #imm32 is (op_maj=0b00001 | op_maj=0b00011) & rd & inv=1 & shl=0 & sh=0 & rx=0 & ry=0 & rs; imm32 { rd = rs - imm32; }

# Subtract from address.
:suba rd, rs, [#imm32] is (op_maj=0b00001 | op_maj=0b00011) & rd & inv=1 & shl=1 & sh=0 & rx=0 & ry=0 & rs; imm32 { rd = rs - *[DM]imm32:4; }


# Logical operations.

:eqz rd, rs is op_maj=0b01100 & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx=31 & rs {
	rd = 0;
	if !(rs == 0) goto <skip>;
	rd = 1;
	<skip>
}

:eq rd, rs, rx is op_maj=0b01100 & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx & rs {
	rd = 0;
	if !(rs == rx) goto <skip>;
	rd = 1;
	<skip>
}

:eqi rd, rs, #imm32 is op_maj=0b01101 & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx=0 & ry=0 & rs; imm32 {
	rd = 0;
	if !(rs == imm32) goto <skip>;
	rd = 1;
	<skip>
}

# Shift register. Really just a specialized form of the "add" and "sub" instructions.
:srl rd,  rx >> #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=0 & shl=0 & sh & rx & rs=31 { rd =  (rx >> sh); }
:srl rd, -rx >> #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=1 & shl=0 & sh & rx & rs=31 { rd = -(rx >> sh); }
:sll rd,  rx << #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=0 & shl=1 & sh & rx & rs=31 { rd =  (rx << sh); }
:sll rd, -rx << #sh is (op_maj=0b00000 | op_maj=0b00010) & rd & inv=1 & shl=1 & sh & rx & rs=31 { rd = -(rx << sh); }

:and rd, rs,  rx is op_maj=0b10000 & rd & inv=0 & (shl=0 | shl=1) & sh=0 & rx & rs { rd = rs &  rx; }
:and rd, rs, ~rx is op_maj=0b10000 & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx & rs { rd = rs & ~rx; }
:and rd, rs,  rx >> #sh is op_maj=0b10000 & rd & inv=0 & shl=0 & sh & rx & rs { rd = rs &  (rx >> sh); }
:and rd, rs, ~rx >> #sh is op_maj=0b10000 & rd & inv=1 & shl=0 & sh & rx & rs { rd = rs & ~(rx >> sh); }
:and rd, rs,  rx << #sh is op_maj=0b10000 & rd & inv=0 & shl=1 & sh & rx & rs { rd = rs &  (rx << sh); }
:and rd, rs, ~rx << #sh is op_maj=0b10000 & rd & inv=1 & shl=1 & sh & rx & rs { rd = rs & ~(rx << sh); }

:andi rd, rs,   #imm32  is op_maj=0b10001 & rd & inv=0 & shl=0 & sh=0 & rs; imm32 { rd = rs &  imm32; }
:andi rd, rs,  ~#imm32  is op_maj=0b10001 & rd & inv=1 & shl=0 & sh=0 & rs; imm32 { rd = rs & ~imm32; }
:anda rd, rs,  [#imm32] is op_maj=0b10001 & rd & inv=0 & shl=1 & sh=0 & rs; imm32 { rd = rs &  (*[DM]imm32:4); }
:anda rd, rs, ~[#imm32] is op_maj=0b10001 & rd & inv=1 & shl=1 & sh=0 & rs; imm32 { rd = rs & ~(*[DM]imm32:4); }

:xor rd, rs, rx is op_maj=0b10010 & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx & rs { rd = rs ^ rx; }
:xor rd, rs, rx >> #sh is op_maj=0b10010 & rd & inv=1 & shl=0 & sh & rx & rs { rd = rs ^ (rx >> sh); }
:xor rd, rs, rx << #sh is op_maj=0b10010 & rd & inv=1 & shl=1 & sh & rx & rs { rd = rs ^ (rx << sh); }

:xori rd, rs,  #imm32  is op_maj=0b10011 & rd & inv=1 & shl=0 & sh=0 & rs; imm32 { rd = rs | imm32; }
:xora rd, rs, [#imm32] is op_maj=0b10011 & rd & inv=1 & shl=1 & sh=0 & rs; imm32 { rd = rs | *[DM]imm32:4; }

:or rd, rs,  rx is op_maj=0b10100 & rd & inv=0 & (shl=0 | shl=1) & sh=0 & rx & rs { rd = rs |  rx; }
:or rd, rs, ~rx is op_maj=0b10100 & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx & rs { rd = rs | ~rx; }
:or rd, rs,  rx >> #sh is op_maj=0b10100 & rd & inv=0 & shl=0 & sh & rx & rs { rd = rs |  (rx >> sh); }
:or rd, rs, ~rx >> #sh is op_maj=0b10100 & rd & inv=1 & shl=0 & sh & rx & rs { rd = rs | ~(rx >> sh); }
:or rd, rs,  rx << #sh is op_maj=0b10100 & rd & inv=0 & shl=1 & sh & rx & rs { rd = rs |  (rx << sh); }
:or rd, rs, ~rx << #sh is op_maj=0b10100 & rd & inv=1 & shl=1 & sh & rx & rs { rd = rs | ~(rx << sh); }

:ori rd, rs,   #imm32  is op_maj=0b10101 & rd & inv=0 & shl=0 & sh=0 & rs; imm32 { rd = rs |  imm32; }
:ori rd, rs,  ~#imm32  is op_maj=0b10101 & rd & inv=1 & shl=0 & sh=0 & rs; imm32 { rd = rs | ~imm32; }
:ora rd, rs,  [#imm32] is op_maj=0b10101 & rd & inv=0 & shl=1 & sh=0 & rs; imm32 { rd = rs |  (*[DM]imm32:4); }
:ora rd, rs, ~[#imm32] is op_maj=0b10101 & rd & inv=1 & shl=1 & sh=0 & rs; imm32 { rd = rs | ~(*[DM]imm32:4); }

:anor rd, rs,  rx, ry is op_maj=0b10110 & rd & inv=0 & (shl=0 | shl=1) & sh=0 & rx & ry & rs { rd = (rs &  rx) | ry; }
:anor rd, rs, ~rx, ry is op_maj=0b10110 & rd & inv=1 & (shl=0 | shl=1) & sh=0 & rx & ry & rs { rd = (rs & ~rx) | ry; }
:anor rd, rs,  rx >> sh, ry is op_maj=0b10110 & rd & inv=0 & shl=0 & sh & rx & ry & rs { rd = (rs &  (rx >> sh)) | ry; }
:anor rd, rs, ~rx >> sh, ry is op_maj=0b10110 & rd & inv=1 & shl=0 & sh & rx & ry & rs { rd = (rs & ~(rx >> sh)) | ry; }
:anor rd, rs,  rx << sh, ry is op_maj=0b10110 & rd & inv=0 & shl=1 & sh & rx & ry & rs { rd = (rs &  (rx << sh)) | ry; }
:anor rd, rs, ~rx << sh, ry is op_maj=0b10110 & rd & inv=1 & shl=1 & sh & rx & ry & rs { rd = (rs & ~(rx << sh)) | ry; }

:anori rd, rs,   #imm32,  ry is op_maj=0b10111 & rd & inv=0 & shl=0 & sh=0 & rx=0 & ry & rs; imm32 { rd = (rs &  imm32)        | ry; }
:anori rd, rs,  ~#imm32,  ry is op_maj=0b10111 & rd & inv=1 & shl=0 & sh=0 & rx=0 & ry & rs; imm32 { rd = (rs & ~imm32)        | ry; }
:anora rd, rs,  [#imm32], ry is op_maj=0b10111 & rd & inv=0 & shl=1 & sh=0 & rx=0 & ry & rs; imm32 { rd = (rs &  (*[DM]imm32:4)) | ry; }
:anora rd, rs, ~[#imm32], ry is op_maj=0b10111 & rd & inv=1 & shl=1 & sh=0 & rx=0 & ry & rs; imm32 { rd = (rs & ~(*[DM]imm32:4)) | ry; }

:anori rd, rs,   #imm32,   #imm32_2  is op_maj=0b10111 & rd & inv=0 & shl=0 & sh=1 & rx=0 & ry=0 & rs; imm32; imm32_2 { rd = (rs &  imm32)          | imm32_2; }
:anori rd, rs,  ~#imm32,   #imm32_2  is op_maj=0b10111 & rd & inv=1 & shl=0 & sh=1 & rx=0 & ry=0 & rs; imm32; imm32_2 { rd = (rs & ~imm32)          | imm32_2; }
:anora rd, rs,  [#imm32], [#imm32_2] is op_maj=0b10111 & rd & inv=0 & shl=1 & sh=1 & rx=0 & ry=0 & rs; imm32; imm32_2 { rd = (rs &  (*[DM]imm32:4)) | *[DM]imm32_2:4; }
:anora rd, rs, ~[#imm32], [#imm32_2] is op_maj=0b10111 & rd & inv=1 & shl=1 & sh=1 & rx=0 & ry=0 & rs; imm32; imm32_2 { rd = (rs & ~(*[DM]imm32:4)) | *[DM]imm32_2:4; }


# Function call, unconditional.
:call rd, #jump_dest is op_maj=0b11000 & rd & ird & rxry [
	jump_dest = rxry * 4;
] {
	delayslot(1);
	r11 = ird;
	call [jump_dest:4];
}


# Function calls, conditional.

:calln rd, rs, #jump_dest is op_maj=0b11001 & rd & ird & inv=0 & rxry & rs [
	jump_dest = rxry * 4;
] {
	local delayflag = (rs != 0);
	delayslot(1);
	if !delayflag goto <skip>;
	r11 = ird;
	call [jump_dest:4];
	<skip>
}

:callz rd, rs, #jump_dest is op_maj=0b11001 & rd & ird & inv=1 & rxry & rs [
	jump_dest = rxry * 4;
] {
	local delayflag = (rs == 0);
	delayslot(1);
	if !delayflag goto <skip>;
	r11 = ird;
	call [jump_dest:4];
	<skip>
}


# Jump, unconditional.
:jump #jump_dest is op_maj=0b11010 & inv=0 & shl=0 & sh=0 & rxry & rs=0 [
	jump_dest = rxry * 4;
] {
	delayslot(1);
	goto [jump_dest:4];
}


# Jumps, conditional.

# Jump if non-zero.
:jumpn rs, #jump_dest is op_maj=0b11011 & inv=0 & rxry & rs [
	jump_dest = rxry * 4;
] {
	local delayflag = (rs != 0);
	delayslot(1);
	if !delayflag goto <skip>;
	goto [jump_dest:4];
	<skip>
}

# Jump if zero.
:jumpz rs, #jump_dest is op_maj=0b11011 & inv=1 & rxry & rs [
	jump_dest = rxry * 4;
] {
	local delayflag = (rs == 0);
	delayslot(1);
	if !delayflag goto <skip>;
	goto [jump_dest:4];
	<skip>
}


# Data stores.

# Store register at an address pointed to by a register.
:store rs, [rd] is op_maj=0b11100 & rd & inv=0 & shl=0 & sh=0 & rx=0 & ry=0 & rs {
	*[DM]:4 rd = rs;
}

# Store a 16-bit instruction immediate at an address pointed to by a register.
:store #immediate, [rd] is op_maj=0b11100 & rd & inv=1 & shl & sh=0 & rxryrs [
	immediate = (shl << 15) | rxryrs;
] {
	*[DM]:4 rd = immediate;
}

# Store one or more immediates at an address pointed to by an immediate.
# TODO: Handle more than one data value.
:storeai [#imm32], #imm32_2 is op_maj=0b11101 & rd=0 & inv=1 & shl=0 & sh=1 & rx=0 & ry=0 & rs=0; imm32; imm32_2 {
	*[DM]:4 imm32:4 = imm32_2;
}


# Function return.
# FIXME: The link register functionality is almost certainly wrong.
:return is op_maj=0b11110 & rd=0 & inv=0 & shl=0 & sh=0 & rx=0 & ry=0 & rs=0 {
	delayslot(1);
	return [r11];
}
